package net.cohesyslab.dc.imitators

import java.util.SplittableRandom

import io.github.carrknight.Observation
import io.github.carrknight.imitators.ExploreAtRandom
import io.github.carrknight.imitators.ExploreExploitImitate
import io.github.carrknight.utils.RewardFunction
import io.github.carrknight.utils.rules.ObservationPredicate
import net.cohesyslab.dc.ChooserObject
import net.cohesyslab.dc.imitators.ExploreExploitImitateChooserPrim.DefaultExplorationProbability
import net.cohesyslab.dc.imitators.ExploreExploitImitateChooserPrim.DefaultImitationProbability
import net.cohesyslab.dc.utils.DoubleSetter
import net.cohesyslab.dc.utils.Getter
import net.cohesyslab.dc.utils.IdentityRewardFunction
import net.cohesyslab.dc.utils.InRange
import net.cohesyslab.dc.utils.RichArgument
import net.cohesyslab.dc.utils.ValidationRule
import org.nlogo.api.AnonymousReporter
import org.nlogo.api.Argument
import org.nlogo.api.Context
import org.nlogo.api.Dump
import org.nlogo.api.ExtensionException
import org.nlogo.api.Reporter
import org.nlogo.api.ScalaConversions._
import org.nlogo.core.LogoList
import org.nlogo.core.Syntax
import org.nlogo.core.Syntax.AgentsetType
import org.nlogo.core.Syntax.ListType
import org.nlogo.core.Syntax.ReporterType
import org.nlogo.core.Syntax.WildcardType
import org.nlogo.core.Syntax.reporterSyntax

object ExploreExploitImitateChooserPrim extends Reporter {

  val DefaultExplorationProbability = 0.2
  val DefaultImitationProbability = 0.2

  override def getSyntax: Syntax = reporterSyntax(
    right = List(
      ListType | AgentsetType, // the choices
      ReporterType // a reporter that should report either a single chooser or a list of choosers to imitate
    ),
    ret = WildcardType
  )
  override def report(args: Array[Argument], context: Context): AnyRef = {
    new ImitatorChooserObject(
      new ExploreExploitImitate[AnyRef, Double, Null](
        IdentityRewardFunction,
        args(0).getOptionsArray,
        new StochasticObservationPredicate[AnyRef, Double, Null](DefaultExplorationProbability),
        new StochasticObservationPredicate[AnyRef, Double, Null](DefaultImitationProbability),
        new SplittableRandom(context.getRNG.nextLong()),
        new ExploreAtRandom[AnyRef, Double, Null] // TODO: make this settable?
      ),
      args(1).getReporter
    )
  }
}

/**
 * Same as {@link io.github.carrknight.utils.rules.StochasticObservationPredicate}
 * but keeps track of the exploration probability.
 */
class StochasticObservationPredicate[O, R, C](val explorationProbability: Double) extends ObservationPredicate[O, R, C] {
  override def shouldExplore(
    lastObservation: Observation[O, R, C],
    currentChoice: O,
    rewardFunction: RewardFunction[O, R, C],
    random: SplittableRandom,
    additionalObservations: Observation[O, R, C]*
  ): Boolean = random.nextDouble < explorationProbability
}

object ImitationProbabilityPrim extends Getter[ExploreExploitImitate[_, _, _]] {
  override def get(chooser: ExploreExploitImitate[_, _, _]): Any =
    chooser.getImitationRule match {
      case rule: StochasticObservationPredicate[_, _, _] => rule.explorationProbability
      case _ => throw new ExtensionException("Imitation rule is not stochastic.")
    }
}

object SetImitationProbabilityPrim extends DoubleSetter[ExploreExploitImitate[AnyRef, Double, Null]] {
  override val validationRule: ValidationRule[Double] = InRange(0, 1)
  override def set(chooser: ExploreExploitImitate[AnyRef, Double, Null], value: Double): Unit =
    chooser.setExplorationRule(new StochasticObservationPredicate[AnyRef, Double, Null](value))
}