package net.cohesyslab.dc.imitators

import java.util.SplittableRandom

import io.github.carrknight.Observation
import io.github.carrknight.imitators.ExploreAtRandom
import io.github.carrknight.imitators.ExploreExploitImitate
import io.github.carrknight.utils.RewardFunction
import io.github.carrknight.utils.rules.ObservationPredicate
import net.cohesyslab.dc.ChooserObject
import net.cohesyslab.dc.utils.DoubleSetter
import net.cohesyslab.dc.utils.Getter
import net.cohesyslab.dc.utils.IdentityRewardFunction
import net.cohesyslab.dc.utils.InRange
import net.cohesyslab.dc.utils.RichArgument
import net.cohesyslab.dc.utils.ValidationRule
import org.nlogo.api.Argument
import org.nlogo.api.Context
import org.nlogo.api.ExtensionException
import org.nlogo.api.Reporter
import org.nlogo.core.Syntax
import org.nlogo.core.Syntax.AgentsetType
import org.nlogo.core.Syntax.ListType
import org.nlogo.core.Syntax.WildcardType
import org.nlogo.core.Syntax.reporterSyntax

object ExploreExploitImitateChooserPrim extends Reporter {

  val DefaultExplorationProbability = 0.2
  val DefaultImitationProbability = 0.2

  override def getSyntax: Syntax = reporterSyntax(
    // TODO: allow setting who we imitate, probably via a (chooser/list of choosers)-reporter (should it be changeable?)
    right = List(ListType | AgentsetType), // the choices
    ret = WildcardType
  )
  override def report(args: Array[Argument], context: Context): AnyRef =
    new ChooserObject(
      new ExploreExploitImitate[AnyRef, Double, Null](
        IdentityRewardFunction,
        args(0).getOptionsArray(context.getRNG),
        new StochasticObservationPredicate[AnyRef, Double, Null](DefaultExplorationProbability),
        new StochasticObservationPredicate[AnyRef, Double, Null](DefaultImitationProbability),
        new SplittableRandom(context.getRNG.nextLong()), // random seed
        new ExploreAtRandom[AnyRef, Double, Null] // TODO: make this settable?
      )
    )
}

/**
 * Same as {@link io.github.carrknight.utils.rules.StochasticObservationPredicate}
 * but keeps track of the exploration probability.
 */
class StochasticObservationPredicate[O, R, C](val explorationProbability: Double) extends ObservationPredicate[O, R, C] {
  override def shouldExplore(
    lastObservation: Observation[O, R, C],
    currentChoice: O,
    rewardFunction: RewardFunction[O, R, C],
    random: SplittableRandom,
    additionalObservations: Observation[O, R, C]*
  ): Boolean = random.nextDouble < explorationProbability
}

object ExplorationProbabilityPrim extends Getter[ExploreExploitImitate[_, _, _]] {
  override def get(chooser: ExploreExploitImitate[_, _, _]): Any =
    chooser.getExplorationRule match {
      case rule: StochasticObservationPredicate[_, _, _] => rule.explorationProbability
      case _ => throw new ExtensionException("Exploration rule is not stochastic.")
    }
}

object SetExplorationProbabilityPrim extends DoubleSetter[ExploreExploitImitate[AnyRef, Double, Null]] {
  override val validationRule: ValidationRule[Double] = InRange(0, 1)
  override def set(chooser: ExploreExploitImitate[AnyRef, Double, Null], value: Double): Unit =
    chooser.setExplorationRule(new StochasticObservationPredicate[AnyRef, Double, Null](value))
}

object ImitationProbabilityPrim extends Getter[ExploreExploitImitate[_, _, _]] {
  override def get(chooser: ExploreExploitImitate[_, _, _]): Any =
    chooser.getImitationRule match {
      case rule: StochasticObservationPredicate[_, _, _] => rule.explorationProbability
      case _ => throw new ExtensionException("Imitation rule is not stochastic.")
    }
}

object SetImitationProbabilityPrim extends DoubleSetter[ExploreExploitImitate[AnyRef, Double, Null]] {
  override val validationRule: ValidationRule[Double] = InRange(0, 1)
  override def set(chooser: ExploreExploitImitate[AnyRef, Double, Null], value: Double): Unit =
    chooser.setExplorationRule(new StochasticObservationPredicate[AnyRef, Double, Null](value))
}